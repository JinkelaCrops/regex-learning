# 正则表达式入门

正则表达式于1960s由Thompson引入Unix系统的标准文本编辑器，自此以后正则表达式被广泛地应用于各种Unix或类Unix系统的工具中。正则表达式遵循一定的规范，最著名的是从Perl衍生出来的PCRE（Per Compatible Regular Expression）规范和POSIX（Portable Operating System Interface for Unix）规范定义的正则规范。目前，各个编程语言都或多或少地支持一定的程度的正则表达式，但是也有一些自己特有的不同之处。

## 引入问题

正则表达式是处理文本和字符串的利器。假设你想检查一个邮箱地址是否合法，如果不用正则表达式，请问你会用什么来处理呢？自己编写一段复杂的字符串匹配的代码吗？利用正则表达式，我们可以使用一句不太长的字符，完成一个很复杂的功能。但是，过长的正则表达式晦涩难懂，即使写出这些正则表达式，过段时间后也不见得能够解释清楚。

带着问题学习，能够有效地增加高级知识，更有针对性，学习效果会更好。为了完成下面的讲述，我们先来看几个问题。

我们使用的文本是医疗领域的50000句中英双语句对
* 中英文中间有空格，将中英文句对拆分
* 中英文中间没有空格，将中英文句对拆分
* 中英文上下对照，拆分为两个文件
* 查找重复的片段
* 查找重复的标点

## 基本概念

1. 元字符

    代码|   说明
    -|:-
    `.` |   匹配除换行符`\n`以外的任意字符
    `\w`| 	匹配字母或数字或下划线或汉字，例如`\w{6}`可以匹配6个字符的单词。
    `\s`| 	匹配任意的空白符
    `\d`| 	匹配数字
    `\b`| 	匹配单词的开始或结束
    `^` |	匹配字符串的开始，在多行匹配中标记了一行的开始
    `$` |	匹配字符串的结束，在多行匹配中标记了一行的结束

    例如：
    * 句子有大写首字母`A`，可以使用`^A`
    * 查找英文单词`regex`，但是又不想匹配`regexexpr`，可以使用`\bregex\b`

2. 重复

    代码| 	说明
    -|:-
    `*` |	重复零次或更多次
    `+` |	重复一次或更多次
    `?` |	重复零次或一次
    `{n}`| 	重复n次
    `{n,}`| 	重复n次或更多次
    `{n,m}`| 	重复n到m次

    例如：
    * `.*`表示匹配任意字符任意次
    * `\w+`表示匹配任意字母或数字或下划线或汉字多余一次，即连续的单词
    * `\d+`表示匹配连续的数字

3. 字符类

    使用`[]`表示任意一个集合内的元素，例如`[abcde]`表示`a`, `b`, `c`, `d`, `e`中的任意一个，`[a-z]`表示任意一个小写英文字母

    例如：
    * `^[A-Z]`表示句首的大写字母
    * `\b[A-Z]+\b`表示大写单词

4. 反义

    使用`[^]`表示任意一个非集合内的元素，例如`[^abcde]`表示除了`a`, `b`, `c`, `d`, `e`的任意一个字符。此外，还有一些元字符的反义：

    代码| 	说明
    -|:-
    `\W`| 	匹配任意不是字母，数字，下划线，汉字的字符
    `\S`| 	匹配任意不是空白符的字符
    `\D`| 	匹配任意非数字的字符
    `\B`| 	匹配不是单词开头或结束的位置

5. 分组

    使用`()`来指定子表达式。子表达式在重复时重复的是表达式而不是捕获的组。`(l[eo]t)+`可以匹配`lotlot`, `letlet`, `lotlet`, `letlot`

    在Notepad++中, 可以使用`\1`, `\2`等来引用捕获的子字符串。注意，被引用的是`()`捕获的子字符串，例如`(l[eo]t)\1`匹配的是`lotlot`, `letlet`而不能匹配`lotlet`, `letlot`
    * 在搜索中，可以使用`\1`, `\2`来引用捕获的子字符串，例如重复的英文单词`\b([A-Za-z]+) +\1\b`
    * 在替换中，引用需要使用`$1`, `$2`，例如在后面没有空格的`.`之后加上空格: 搜索`\.([A-Z])`, 替换为`. $1`, 替换框中的内容不需要转义
    
    在AntConc中
    * 搜索时无法使用`\1`, `\2`来引用捕获的子字符串, 而是要使用标记组`(?<name>exp)`和`\k<name>`, 例如连续的英文单词`\b(?<分组1>[A-Za-z]+) +\k<分组1>\b`, 在Notepad++中也能通过

6. 分支条件

    使用`|`来表示分支条件，也即或的概念。例如，要匹配1900-2099全部的年份, `(19|20)[0-9]{2}`

7. 字符转义

    需要在想要查找的元字符之前加上`\`

    列举正则中需要转义的字符： `.` `^` `$` `*` `+` `?` `[` `]` `{` `}` `(` `)` `-` `\` `|`


## 高级概念

1. 零宽断言

    有一种特殊的分组并不会被捕获，这就是零宽断言。零宽断言在查找替换时很有用。下面先给出最常用的几种分组语法：

    分类| 	代码| 	说明
    --- |-|:-
    捕获 |	`(exp)` |	匹配exp,并捕获文本到自动命名的组里
    -|`(?<name>exp)` |	匹配exp,并捕获文本到名称为name的组里，也可以写成`(?'name'exp)`
    -|`(?:exp)` |	匹配exp,不捕获匹配的文本，也不给此分组分配组号
    零宽断言|`(?=exp)` |	匹配exp前面的位置
    -|`(?<=exp)`|	匹配exp后面的位置
    -|`(?!exp)` |	匹配后面跟的不是exp的位置
    -|`(?<!exp)`|	匹配前面不是exp的位置
    注释 |	`(?#comment)` |	这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读

    首先来看捕获。我们已经熟悉了最简单的捕获`(exp)`，这里还有两个：`(?<name>exp)`和`(?:exp)`。例如：`(?<name>[abc]) \k<name>`可以匹配`a a`, `b b`, `c c`；而`(?:a|b)c`虽然和`(a|b)c`功能一样，但是不会捕获组，这使得在运行正则时开销更小。

    再来看零宽断言。`q(?=u)`可以匹配所有后面紧跟着`u`的`q`，而`(?<=q)u`可以匹配所有前面是`q`的`u`。具体一点，我们想要找到所有后面没有空格的`.`，并在`.`后加上空格，我们可以这样写：

    在Notepad++中搜索`(?<=\.)(?=[A-Z])`，替换为空格。使用`\.(?=[A-Z])`可以在AntConc中定位到所有的满足条件的`.`。

    可以看到我们并没有捕获`\.`和`[A-Z]`。当想要实现的功能变得复杂时，使用零宽断言可以简化书写。

    而负向零宽断言`(?!exp)` `(?<!exp)`则与零宽断言相反，**不会**匹配后面/前面为`exp`的内容，例如：
    
    `(?<=[一-龥])[A-Za-z]+(?=[一-龥])` 匹配前后都是汉字的英文单词

    `(?<![一-龥A-Za-z])[A-Za-z]+(?![一-龥A-Za-z])` 匹配前后都不是汉字的英文单词

2. 贪婪与懒惰
    
    代码| 	说明
    -|:-
    `*?`| 	重复任意次，但尽可能少重复
    `+?`| 	重复1次或更多次，但尽可能少重复
    `??`| 	重复0次或1次，但尽可能少重复
    `{n,m}?`| 	重复n到m次，但尽可能少重复
    `{n,}?`| 	重复n次以上，但尽可能少重复

    例如，要匹配`looootloooot`，`l.*t`会匹配`looootloooot`，而`l.*?t`则只会匹配`loooot`。

3. 字符编码

    使用`\x{0041}`, `{}`中写入4位的16进制数，可以匹配一个unicode字符，比如匹配中文：`[一-龥]`，如果我们熟知中文对应的unicode编码，可以写成`[\x{4e00}-\x{9fa5}]`。

    有一些特殊字符，制表符`\t`，换行符`\n`。

4. 平衡组

    平衡组可以对配对括号进行检验，一个很实在的应用就是返回一个字符串里最长的html标签。

## 参考

* Unicode字符：
    * Unicode字符列表: https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8
    * Unicode/Character reference: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF
    * Unicode 10.0 Character Code Charts: https://www.unicode.org/charts
    * 世界文字大全，Unicode 字符集: http://www.qqxiuzi.cn/zh/unicode-zifu.php?plane=0&ks=0000&js=0FFF

* 正则表达式30分钟入门教程: http://deerchao.net/tutorials/regex/regex.htm

* 正则表达式菜鸟教程: http://www.runoob.com/regexp/regexp-syntax.html

* Notepad++: https://notepad-plus-plus.org/

* Notepad++ Regex Tutorial: http://docs.notepad-plus-plus.org/index.php/Regular_Expressions

## 练习

1. 中英文中间有空格，将中英文句对拆分

    假定中文中没有空格，英文中存在空格，只需要查找最后一个空格即可

    `^([^ \n]+) ` -> `$1 ||| `

2. 中英文中间没有空格，将中英文句对拆分

    假定中文中没有英文，只需要查找第一个英文

    `^([^A-Za-z]+)([A-Za-z])` -> `$1 ||| $2`

    但是如果遇到英文以数字或者标点开头的情况就有问题，例如`12例病人12 patients`

    假定英文中没有中文，只需要查找最后一个中文

    `([\x{4e00}-\x{9fff}])([^\x{4e00}-\x{9fff}]+)$` -> `$1 ||| $2`

    但是如果遇到中文以数字或者标点结尾的情况就有问题，例如`12例病人。12 patients.`

3. 中英文上下对照，拆分为两个文件

    `(.*)\n(.*)\n` -> `$1\n`

    `(.*)\n(.*)\n` -> `$2\n`

4. 查找重复的片段

    `\b(.+?)\b( *\b\1\b)+`

    `\b(?<w1>.+?)\b( *\b\k<w1>\b)+`   （`.+`极其消耗资源）

5. 查找重复的标点

    `(\.\.\.|……|——|[,.!?;:"“”‘’·…\-—()\[\]{}，。！？；：（）【】])( +\1)+`

    `(?<w1>\.\.\.|……|——|[,.!?;:"“”‘’·…\-—()\[\]{}，。！？；：（）【】])( +\k<w1>)+`